package accumulator

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"strconv"
)

const (
	securityPara      = 2048
	randomizerSetSize = 256
	// Note that the securityParaHashToPrime is running securityParaHashToPrime rounds of Miller-Robin test
	// together with one time Baillie-PSW test. Totally heuristic value for now.
	securityParaHashToPrime = 10

	// N2048String is the 2048-bit RSA challenge from
	// https://en.wikipedia.org/wiki/RSA_numbers#RSA-2048
	N2048String = "25195908475657893494027183240048398571429282126204032027777137836043662020707" +
		"595556264018525880784406918290641249515082189298559149176184502808489120072844992687392" +
		"807287776735971418347270261896375014971824691165077613379859095700097330459748808428401" +
		"797429100642458691817195118746121515172654632282216869987549182422433637259085141865462" +
		"043576798423387184774447920739934236584823824281198163815010674810451660377306056201619" +
		"676256133844143603833904414952634432190114657544454178424020924616515723350778707749817" +
		"125772467962926386356373289912154831438167899885040445364023527381951378636564391212010" +
		"397122822120720357"

	// G2048String is G pre-generated by hashing N through the function GenerateG(), note that any
	// random number mod N should be work as a generator with overwhelming probability
	G2048String = "36125180748779554123318199528005871686928236606042204413251191061822430425687" +
		"097704510976488543824243179913290584144436352212180077777575622132603869467725015452687" +
		"577558100111714219271760576805344783165349591064198064676135142439712338008861846522056" +
		"427403061246985424478132337120980261658728214246688350441613778300557652897599345354068" +
		"266055428231521103562770253071174296266251675923799437936650173416839455059378970103740" +
		"942419460436082633536437816415174009734025695067902861309122781712179279787649475651300" +
		"600345042772613903033967878379857249999473018461052103366618611873817620719707699275384" +
		"636400658849792"
	// HashToPrimeFromSha256 is a prime number generated from Sha256
	HashToPrimeFromSha256 = iota
	// DIHashFromPoseidon is a division intractable Hash output
	DIHashFromPoseidon
)

var (
	one = big.NewInt(1)

	// Min2048 is set to a 2048 bits number with most significant bit 1 and other bits 0
	// This can speed up the calculation
	Min2048 = big.NewInt(0)
)

// Setup is a basic struct for a hidden order group
type Setup struct {
	N *big.Int
	G *big.Int //default generator in Z*_N
}

// Element should be able to be accumulated into RSA accumulator
type Element []byte

// EncodeType is the type of generating Element, should be consistent all the time
type EncodeType int

// GenerateG generates a generator for a hidden order group randomly
func GenerateG() {
	buffer := make([]big.Int, 8)
	buffer[0].Set(SHA256ToInt([]byte(N2048String))) //g1 should be 256 bit.
	for i := 1; i < 8; i++ {
		buffer[i].Set(SHA256ToInt(buffer[i-1].Bytes()))
	}
	prod := SetProduct(buffer)
	var N big.Int
	N.SetString(N2048String, 10)
	prod.Mod(prod, &N)
	fmt.Println("prod = ", prod.String())
	var gcd big.Int
	gcd.GCD(nil, nil, &N, prod)
	if gcd.Cmp(one) != 0 {
		// gcd != 1
		//this condition should never happen
		fmt.Println("g and N not co-prime! We win the RSA-2048 challenge!")
	}
}

// SetProduct calculates the products of the input set
func SetProduct(inputSet []big.Int) *big.Int {
	var ret big.Int
	setSize := len(inputSet)
	ret.Set(one)
	// ret is set to 1
	for i := 0; i < setSize; i++ {
		ret.Mul(&ret, &inputSet[i])
	}
	return &ret
}

// GetPseudoRandomElement returns the pseudo random element from the input integer, for test use only
func GetPseudoRandomElement(input int) *Element {
	var ret Element
	temp := strconv.Itoa(input)
	ret = []byte(temp[:])
	return &ret
}

// flipCoin outputs 1/0 with equal probability
func flipCoin() bool {
	//Int returns a uniform random value in [0, max)
	result, err := rand.Int(rand.Reader, big.NewInt(100))
	if err != nil {
		panic(err)
	}
	if result.Int64() < 50 {
		return true
	}
	return false
}

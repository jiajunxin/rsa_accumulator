package accumulator

import (
	crand "crypto/rand"
	"fmt"
	"math/big"
	"math/rand"
	"strconv"
)

const (
	securityPara       = 2048
	securityParaInBits = 128

	// N2048String is the 2048 bit RSA challenge from
	// https://en.wikipedia.org/wiki/RSA_numbers#RSA-2048
	N2048String = `25195908475657893494027183240048398571429282126204032027777137836043662020707595
				   55626401852588078440691829064124951508218929855914917618450280848912007284499268
				   73928072877767359714183472702618963750149718246911650776133798590957000973304597
				   48808428401797429100642458691817195118746121515172654632282216869987549182422433
				   63725908514186546204357679842338718477444792073993423658482382428119816381501067
				   48104516603773060562016196762561338441436038339044149526344321901146575444541784
				   24020924616515723350778707749817125772467962926386356373289912154831438167899885
				   040445364023527381951378636564391212010397122822120720357`

	// G2048String is G pre-generated by hashing N through the function GenerateG(), note that any
	// random number mod N should be work as a generator with overwhelming probability
	G2048String = `36125180748779554123318199528005871686928236606042204413251191061822430425687097
				   70451097648854382424317991329058414443635221218007777757562213260386946772501545
				   26875775581001117142192717605768053447831653495910641980646761351424397123380088
				   61846522056427403061246985424478132337120980261658728214246688350441613778300557
				   65289759934535406826605542823152110356277025307117429626625167592379943793665017
				   34168394550593789701037409424194604360826335364378164151740097340256950679028613
				   09122781712179279787649475651300600345042772613903033967878379857249999473018461
				   052103366618611873817620719707699275384636400658849792`
	// HashToPrimeFromSha256 is a prime number generatted from Sha256
	HashToPrimeFromSha256 = iota
	// DIHashFromPoseidon is a division intractable Hash output
	DIHashFromPoseidon
)

var (
	zero = big.NewInt(0)
	one  = big.NewInt(1)
	two  = big.NewInt(2)

	// Min2048 is set to a 2048 bits number with most significant bit 1 and other bits 0
	// This can speed up the calculation
	Min2048 = big.NewInt(0)
)

// AccumulatorSetup is a basic struct for a hidden order group
type AccumulatorSetup struct {
	N big.Int
	G big.Int //default generator in Z*_N
}

// Element should be able to be accumulated into RSA accumulator
type Element []byte

// EncodeType is the type of generating Element, should be consistent all the time
type EncodeType int

// GenerateG generates a generator for a hidden order group randomly
func GenerateG() {
	buffer := make([]big.Int, 8)
	buffer[0].Set(SHA256ToInt([]byte(N2048String))) //g1 should be 256 bit.
	for i := 1; i < 8; i++ {
		buffer[i].Set(SHA256ToInt(buffer[i-1].Bytes()))
	}
	prod := SetProduct(buffer)
	var N big.Int
	N.SetString(N2048String, 10)
	prod.Mod(prod, &N)
	fmt.Println("prod = ", prod.String())
	var gcd big.Int
	gcd.GCD(nil, nil, &N, prod)
	if gcd.Cmp(one) != 0 {
		// gcd != 1
		//this condition should never happen
		fmt.Println("g and N not co-prime! We win the RSA-2048 challenge!")
	}
}

// SetProduct calculates the products of the input set
func SetProduct(inputSet []big.Int) *big.Int {
	var ret big.Int
	setSize := len(inputSet)
	ret.Set(one)
	// ret is set to 1
	for i := 0; i < setSize; i++ {
		ret.Mul(&ret, &inputSet[i])
	}
	return &ret
}

// GetPseudoRandomElement returns the pseudo random element from the input integer, for test use only
func GetPseudoRandomElement(input int) *Element {
	var ret Element
	temp := strconv.Itoa(input)
	ret = []byte(temp[:])
	return &ret
}

func getSafePrime() *big.Int {
	ranNum, _ := crand.Prime(crand.Reader, securityPara/2)
	var temp big.Int
	flag := false
	for !flag {
		temp.Mul(ranNum, two)
		temp.Add(&temp, one)
		flag = temp.ProbablyPrime(securityParaInBits / 2)
		if !flag {
			ranNum, _ = crand.Prime(crand.Reader, securityPara)
		}
	}
	return &temp
}

func getRanQR(p, q *big.Int) *big.Int {
	rng := rand.New(rand.NewSource(123456))
	var N big.Int
	N.Mul(p, q)
	var ranNum big.Int
	ranNum.Rand(rng, &N)

	flag := false
	for !flag {
		flag = isQR(&ranNum, p, q)
		if !flag {
			ranNum.Rand(rng, &N)
		}
	}
	return &ranNum
}

func isQR(input, p, q *big.Int) bool {
	if big.Jacobi(input, p) == 1 && big.Jacobi(input, q) == 1 {
		return true
	}
	return false
}

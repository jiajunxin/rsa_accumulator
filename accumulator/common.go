package accumulator

import (
	"fmt"
	"math/big"
	"strconv"
)

const securityPara = 2048
const securityParaInBits = 128
const crs = "HKUST2021" //used as the seed for generating random numbers
const crsNum = 100      //used as the seed for generating random numbers
const PreComputeSize = 200

// N2048String is the 2048 bit RSA challenge from https://en.wikipedia.org/wiki/RSA_numbers#RSA-2048
const N2048String = "25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357"

// G2048String is G pre-generated by hashing N through the function GenerateG(), note that any random number mod N should be fine with overwhelming probability
const G2048String = "36125180748779554123318199528005871686928236606042204413251191061822430425687097704510976488543824243179913290584144436352212180077777575622132603869467725015452687577558100111714219271760576805344783165349591064198064676135142439712338008861846522056427403061246985424478132337120980261658728214246688350441613778300557652897599345354068266055428231521103562770253071174296266251675923799437936650173416839455059378970103740942419460436082633536437816415174009734025695067902861309122781712179279787649475651300600345042772613903033967878379857249999473018461052103366618611873817620719707699275384636400658849792"

var zero = big.NewInt(0)
var one = big.NewInt(1)
var two = big.NewInt(2)
var Max2048 = big.NewInt(0)

type AccumulatorSetup struct {
	N big.Int
	G big.Int //default generator in Z*_N
}

type Element []byte

func GenerateG() {
	buffer := make([]big.Int, 8, 8)
	buffer[0].Set(SHA256ToInt([]byte(N2048String))) //g1 should be 256 bit.
	for i := 1; i < 8; i++ {
		buffer[i].Set(SHA256ToInt(buffer[i-1].Bytes()))
	}
	prod := SetProduct(buffer)
	var N big.Int
	N.SetString(N2048String, 10)
	prod.Mod(prod, &N)
	fmt.Println("prod = ")
	fmt.Println(prod.String())
}

// SetProduct calculates the products of the input set
func SetProduct(inputSet []big.Int) *big.Int {
	var ret big.Int
	setSize := len(inputSet)
	ret.Set(one)
	// ret is set to 1
	for i := 0; i < setSize; i++ {
		ret.Mul(&ret, &inputSet[i])
	}
	return &ret
}

// GetPseudoRandomElement returns the pseudo random element from the input integer, for test use only
func GetPseudoRandomElement(input int) *Element {
	var ret Element
	temp := strconv.Itoa(input)
	ret = []byte(temp[:])
	return &ret
}

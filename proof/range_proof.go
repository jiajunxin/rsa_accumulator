package proof

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
)

var (
	_B           = big.NewInt(4096)
	securityPara = big.NewInt(128)
)

// RPCommitment is the range proof commitment generated by the prover
type RPCommitment []byte

// RPChallenge is the challenge for range proof
type RPChallenge *big.Int

// RPResponse is the response sent by the prover after receiving verifier's challenge
type RPResponse struct {
	ZList [squareNum]*big.Int
	TList [squareNum]*big.Int
	T     *big.Int
}

// NewRPCommitment generates a new commitment for range proof
func NewRPCommitment(dList [squareNum]*big.Int, d *big.Int) RPCommitment {
	var dByteList [squareNum][]byte
	for i := 0; i < squareNum; i++ {
		dByteList[i] = dList[i].Bytes()
	}
	dBytes := d.Bytes()
	hashF := crypto.SHA256.New()
	var sha256List [squareNum][]byte
	for i, dByte := range dByteList {
		hashF.Write(dByte)
		sha256List[i] = hashF.Sum(nil)
		hashF.Reset()
	}
	var hashResult RPCommitment
	for _, s := range sha256List {
		hashResult = append(hashResult, s...)
	}
	hashF.Write(dBytes)
	hashResult = append(hashResult, hashF.Sum(nil)...)
	return hashResult
}

// CommitX is the commitment for non-negative integer x
type CommitX [squareNum]*big.Int

// RPProver refers to the Prover in zero-knowledge integer range proof
type RPProver struct {
	pp          *PublicParameters
	x           *big.Int
	r           *big.Int
	sp          *big.Int
	C           *big.Int
	fourSquareX FourSquare
	commitFSX   FourSquare
	randomMList RPRandomCoins
	randomRList RPRandomCoins
	randomSList RPRandomCoins
	randomS     *big.Int
}

// NewRPProver generates a new range proof prover
func NewRPProver(r, x *big.Int, pp *PublicParameters) *RPProver {
	prover := &RPProver{
		pp: pp,
		x:  x,
		r:  r,
		sp: securityPara,
	}
	prover.calC()
	return prover
}

func (r *RPProver) calC() *big.Int {
	r.C = new(big.Int).Exp(r.pp.G, r.x, r.pp.N)
	r.C.Mul(r.C, new(big.Int).Exp(r.pp.H, r.r, r.pp.N))
	r.C.Mod(r.C, r.pp.N)
	return r.C
}

// CommitX generates the commitment for x
func (r *RPProver) CommitX() ([squareNum]*big.Int, error) {
	// calculate lagrange four squares for x
	fs, err := LagrangeFourSquares(r.x)
	if err != nil {
		return [squareNum]*big.Int{}, err
	}
	r.fourSquareX = fs
	// calculate commitment for x
	rc, err := NewRPRandomCoins(r.pp.N)
	if err != nil {
		return [squareNum]*big.Int{}, err
	}
	r.randomRList = rc
	cList := fs.RangeProofCommit(r.pp, rc)
	r.commitFSX = cList
	return cList, nil
}

// ComposeCommitment composes the commitment for range proof
func (r *RPProver) ComposeCommitment() (RPCommitment, error) {
	// pick m1, m2, m3, m4
	mLmt := big.NewInt(2)
	powMLmt := new(big.Int).Set(_B)
	powMLmt.Div(powMLmt, big2)
	powMLmtPart := new(big.Int).Set(r.sp)
	powMLmtPart.Mul(powMLmtPart, big2)
	powMLmt.Add(powMLmt, powMLmtPart)
	mLmt.Exp(mLmt, powMLmt, nil)
	mList, err := NewRPRandomCoins(mLmt)
	if err != nil {
		return nil, err
	}
	r.randomMList = mList
	// pick s1, s2, s3, s4
	sLmt := big.NewInt(2)
	powSLmt := new(big.Int).Mul(r.sp, big2)
	sLmt.Exp(sLmt, powSLmt, nil)
	sLmt.Mul(sLmt, r.pp.N)
	sList, err := NewRPRandomCoins(sLmt)
	if err != nil {
		return nil, err
	}
	r.randomSList = sList
	sLmt.Set(mLmt)
	sLmt.Mul(sLmt, r.pp.N)
	s, err := PseudoFreshRandomCoin(sLmt)
	if err != nil {
		return nil, err
	}
	r.randomS = s
	// calculate commitment
	dList := calDiList(r.pp, mList, sList)
	d := calD(s, r.pp.H, r.pp.N, r.commitFSX, mList)
	c := NewRPCommitment(dList, d)
	return c, nil
}

func calDiList(pp *PublicParameters, m, s RPRandomCoins) [squareNum]*big.Int {
	var dList [squareNum]*big.Int
	for i := 0; i < squareNum; i++ {
		dList[i] = calDi(pp.G, pp.H, m[i], s[i], pp.N)
	}
	return dList
}

func calDi(g, h, mi, si, n *big.Int) *big.Int {
	res := new(big.Int).Set(g)
	res.Exp(res, mi, n)
	res.Mul(res, new(big.Int).Exp(h, si, n))
	res.Mod(res, n)
	return res
}

func calD(s, h, n *big.Int, c FourSquare, m RPRandomCoins) *big.Int {
	hPowS := new(big.Int).Exp(h, s, n)
	var cPowMList [squareNum]*big.Int
	for i := 0; i < squareNum; i++ {
		cPowMList[i] = new(big.Int).Exp(c[i], m[i], n)
	}
	d := big.NewInt(1)
	for i := 0; i < squareNum; i++ {
		d.Mul(d, cPowMList[i])
		d.Mod(d, n)
	}
	d.Mul(d, hPowS)
	d.Mod(d, n)
	return d
}

// Response generates the response for verifier's challenge
func (r *RPProver) Response(e *big.Int) (*RPResponse, error) {
	var zList [squareNum]*big.Int
	for i := 0; i < squareNum; i++ {
		zList[i] = new(big.Int).Mul(e, r.fourSquareX[i])
		zList[i].Add(zList[i], r.randomMList[i])
	}
	var tList [squareNum]*big.Int
	for i := 0; i < squareNum; i++ {
		tList[i] = new(big.Int).Mul(e, r.randomRList[i])
		tList[i].Add(tList[i], r.randomSList[i])
	}

	sumXR := big.NewInt(0)
	for i := 0; i < squareNum; i++ {
		sumXR.Add(sumXR, new(big.Int).Mul(r.fourSquareX[i], r.randomRList[i]))
	}
	t := new(big.Int).Sub(r.r, sumXR)
	t.Mul(t, e)
	t.Add(t, r.randomS)
	response := &RPResponse{
		ZList: zList,
		TList: tList,
		T:     t,
	}
	return response, nil
}

// RPVerifier refers to the Verifier in zero-knowledge integer range proof
type RPVerifier struct {
	pp         *PublicParameters
	sp         *big.Int
	C          *big.Int
	commitment RPCommitment
}

// NewRPVerifier generates a new range proof verifier
func NewRPVerifier(c *big.Int, pp *PublicParameters) *RPVerifier {
	verifier := &RPVerifier{
		pp: pp,
		sp: securityPara,
		C:  c,
	}
	return verifier
}

// SetCommitment sets the commitment to the verifier
func (r *RPVerifier) SetCommitment(c RPCommitment) {
	r.commitment = c
}

// Challenge generates a challenge for prover's commitment
func (r *RPVerifier) Challenge() (*big.Int, error) {
	eLmt := big.NewInt(2)
	eLmt.Exp(eLmt, r.sp, nil)
	e, err := PseudoFreshRandomCoin(eLmt)
	if err != nil {
		return nil, err
	}
	return e, nil
}

// Verify verifies the response, if accepts, return true; otherwise, return false
func (r *RPVerifier) Verify(e *big.Int, cx CommitX, response *RPResponse) bool {
	var gPowZHPowTCPowNegEModNList [squareNum]*big.Int
	negE := new(big.Int).Neg(e)
	for i := 0; i < squareNum; i++ {
		gPowZHPowTCPowNegEModNList[i] = new(big.Int).Exp(r.pp.G, response.ZList[i], r.pp.N)
		gPowZHPowTCPowNegEModNList[i].Mul(
			gPowZHPowTCPowNegEModNList[i],
			new(big.Int).Exp(r.pp.H, response.TList[i], r.pp.N),
		)
		gPowZHPowTCPowNegEModNList[i].Mul(
			gPowZHPowTCPowNegEModNList[i],
			new(big.Int).Exp(cx[i], negE, r.pp.N),
		)
		gPowZHPowTCPowNegEModNList[i].Mod(gPowZHPowTCPowNegEModNList[i], r.pp.N)
	}

	cPowNegE := new(big.Int).Exp(r.C, negE, r.pp.N)
	hPowT := new(big.Int).Exp(r.pp.H, response.T, r.pp.N)
	prodCiPowZiHPowTCPowNegE := big.NewInt(1)
	for i := 0; i < squareNum; i++ {
		prodCiPowZiHPowTCPowNegE.Mul(
			prodCiPowZiHPowTCPowNegE,
			new(big.Int).Exp(cx[i], response.ZList[i], r.pp.N),
		)
		prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.pp.N)
	}
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, hPowT)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.pp.N)
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, cPowNegE)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.pp.N)

	hashF := sha256.New()
	var sha256List [squareNum][]byte
	for i := 0; i < squareNum; i++ {
		hashF.Write(gPowZHPowTCPowNegEModNList[i].Bytes())
		sha256List[i] = hashF.Sum(nil)
		hashF.Reset()
	}
	hashF.Write(prodCiPowZiHPowTCPowNegE.Bytes())
	h := hashF.Sum(nil)
	var hashResult []byte
	for i := 0; i < squareNum; i++ {
		hashResult = append(hashResult, sha256List[i]...)
	}
	hashResult = append(hashResult, h...)

	for i := 0; i < len(hashResult); i++ {
		if hashResult[i] != r.commitment[i] {
			break
		}
	}

	return bytes.Equal(hashResult, r.commitment)
}

// PublicParameters holds public parameters initialized during the setup procedure
type PublicParameters struct {
	N *big.Int
	G *big.Int
	H *big.Int
}

// NewPublicParameters generates a new public parameter configuration
func NewPublicParameters(n, g, h *big.Int) *PublicParameters {
	return &PublicParameters{N: n, G: g, H: h}
}

// RPRandomCoins is the random coins used in range proof
type RPRandomCoins [squareNum]*big.Int

// NewRPRandomCoins creates a new random coins for range proof
func NewRPRandomCoins(n *big.Int) (coins RPRandomCoins, err error) {
	for i := 0; i < squareNum; i++ {
		coins[i], err = PseudoFreshRandomCoin(n)
		if err != nil {
			return
		}
	}
	return
}

// PseudoFreshRandomCoin creates a new fresh random coin in [0, n]
func PseudoFreshRandomCoin(n *big.Int) (*big.Int, error) {
	lmt := new(big.Int).Set(n)
	lmt.Add(lmt, big1)
	res, err := rand.Int(rand.Reader, lmt)
	if err != nil {
		return nil, err
	}
	return res, nil
}

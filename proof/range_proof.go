package proof

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"math/big"
)

// RPRange is the range in range proof
type RPRange struct {
	A *big.Int
	B *big.Int
}

// RPCommitment is the range proof commitment generated by the prover
type RPCommitment struct {
	Content []byte
}

// RPChallenge is the challenge for range proof
type RPChallenge *big.Int

type RPResponse struct {
	Z1 *big.Int
	Z2 *big.Int
	Z3 *big.Int
	Z4 *big.Int
	T1 *big.Int
	T2 *big.Int
	T3 *big.Int
	T4 *big.Int
	T  *big.Int
}

// NewRPCommitment generates a new commitment for range proof
func NewRPCommitment(d1, d2, d3, d4, d *big.Int) *RPCommitment {
	d1Bytes := d1.Bytes()
	d2Bytes := d2.Bytes()
	d3Bytes := d3.Bytes()
	d4Bytes := d4.Bytes()
	dBytes := d.Bytes()
	hashF := crypto.SHA256.New()
	hashF.Write(d1Bytes)
	hashF.Write(d2Bytes)
	hashF.Write(d3Bytes)
	hashF.Write(d4Bytes)
	hashF.Write(dBytes)
	return &RPCommitment{Content: hashF.Sum(nil)}
}

type CommitX struct {
	C1, C2, C3, C4 *big.Int
}

// RPProver refers to the Prover in zero-knowledge integer range proof
type RPProver struct {
	PP            *PublicParameters
	X             *big.Int
	C             *big.Int
	R             *big.Int
	SecurityParam *big.Int
	Range         *RPRange
	FourSquareX   *FourSquare
	CommitFSX     *FourSquare
	RandomMList   *RPRandomCoins
	RandomRList   *RPRandomCoins
	RandomSList   *RPRandomCoins
	RandomR       *big.Int
	RandomS       *big.Int
}

func (r *RPProver) CalC() *big.Int {
	r.C = new(big.Int).Exp(r.PP.G, r.X, nil)
	r.C.Mul(r.C, new(big.Int).Exp(r.PP.H, r.R, nil))
	return r.C
}

// CommitX generates the commitment for X
func (r *RPProver) CommitX() (c1, c2, c3, c4 *big.Int, err error) {
	// calculate lagrange four squares for x
	fs, err := LagrangeFourSquares(r.X)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	r.FourSquareX = fs
	fmt.Printf("lagrange four squares for x: %v\n", fs)
	// calculate commitment for x
	rc, err := NewRPRandomCoins(r.PP.N)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	r.RandomRList = rc
	c1, c2, c3, c4 = fs.RangeProofCommit(r.PP, rc)
	fmt.Println("run here")
	r.CommitFSX = NewFourSquare(c1, c2, c3, c4)
	return
}

// ComposeCommitment composes the commitment for range proof
func (r *RPProver) ComposeCommitment() (*RPCommitment, error) {
	// pick m1, m2, m3, m4
	mLmt := big.NewInt(2)
	powMLmt := new(big.Int).Set(calBound(r.Range))
	powMLmt.Div(powMLmt, big2)
	powMLmtPart := new(big.Int).Set(r.SecurityParam)
	powMLmtPart.Mul(powMLmtPart, big2)
	powMLmt.Add(powMLmt, powMLmtPart)
	mLmt.Exp(mLmt, powMLmt, nil)
	mList, err := NewRPRandomCoins(mLmt)
	if err != nil {
		return nil, err
	}
	r.RandomMList = mList
	fmt.Println("mlist done")
	// pick s1, s2, s3, s4
	sLmt := big.NewInt(2)
	powSLmt := new(big.Int).Mul(r.SecurityParam, big2)
	sLmt.Exp(sLmt, powSLmt, nil)
	sLmt.Mul(sLmt, r.PP.N)
	sList, err := NewRPRandomCoins(sLmt)
	if err != nil {
		return nil, err
	}
	fmt.Println("slist done")
	r.RandomSList = sList
	sLmt.Set(mLmt)
	sLmt.Mul(sLmt, r.PP.N)
	s, err := PseudoFreshRandomCoin(sLmt)
	if err != nil {
		return nil, err
	}
	r.RandomS = s
	// calculate commitment
	d1, d2, d3, d4 := calDiList(r.PP, mList, sList)
	d := calD(s, r.PP.H, r.PP.N, r.CommitFSX, mList)
	c := NewRPCommitment(d1, d2, d3, d4, d)
	fmt.Println(len(c.Content))
	return c, nil
}

func calDiList(pp *PublicParameters, m, s *RPRandomCoins) (d1, d2, d3, d4 *big.Int) {
	d1 = calDi(pp.G, pp.H, m.R1, s.R1, pp.N)
	d2 = calDi(pp.G, pp.H, m.R2, s.R2, pp.N)
	d3 = calDi(pp.G, pp.H, m.R3, s.R3, pp.N)
	d4 = calDi(pp.G, pp.H, m.R4, s.R4, pp.N)
	return
}

func calDi(g, h, mi, si, n *big.Int) *big.Int {
	res := new(big.Int).Set(g)
	res.Exp(res, mi, n)
	res.Mul(res, new(big.Int).Exp(h, si, n))
	res.Mod(res, n)
	return res
}

func calD(s, h, n *big.Int, c *FourSquare, m *RPRandomCoins) *big.Int {
	hPowS := new(big.Int).Exp(h, s, n)
	c1PowM1 := new(big.Int).Exp(c.W1, m.R1, n)
	c2PowM2 := new(big.Int).Exp(c.W2, m.R2, n)
	c3PowM3 := new(big.Int).Exp(c.W3, m.R3, n)
	c4PowM4 := new(big.Int).Exp(c.W4, m.R4, n)
	d := new(big.Int).Mul(c1PowM1, hPowS)
	d.Mul(d, c2PowM2)
	d.Mul(d, hPowS)
	d.Mul(d, c3PowM3)
	d.Mul(d, hPowS)
	d.Mul(d, c4PowM4)
	d.Mod(d, n)
	return d
}

func (r *RPProver) Response(e *big.Int) (*RPResponse, error) {
	z1 := new(big.Int).Mul(e, r.FourSquareX.W1)
	z1.Add(z1, r.RandomMList.R1)
	z2 := new(big.Int).Mul(e, r.FourSquareX.W2)
	z2.Add(z2, r.RandomMList.R2)
	z3 := new(big.Int).Mul(e, r.FourSquareX.W3)
	z3.Add(z3, r.RandomMList.R3)
	z4 := new(big.Int).Mul(e, r.FourSquareX.W4)
	z4.Add(z4, r.RandomMList.R4)
	t1 := new(big.Int).Mul(e, r.RandomRList.R1)
	t1.Add(t1, r.RandomSList.R1)
	t2 := new(big.Int).Mul(e, r.RandomRList.R2)
	t2.Add(t2, r.RandomSList.R2)
	t3 := new(big.Int).Mul(e, r.RandomRList.R3)
	t3.Add(t3, r.RandomSList.R3)
	t4 := new(big.Int).Mul(e, r.RandomRList.R4)
	t4.Add(t4, r.RandomSList.R4)

	sumXiRi := new(big.Int).Mul(r.RandomSList.R1, r.RandomRList.R1)
	sumXiRi.Add(sumXiRi, new(big.Int).Mul(r.RandomSList.R2, r.RandomRList.R2))
	sumXiRi.Add(sumXiRi, new(big.Int).Mul(r.RandomSList.R3, r.RandomRList.R3))
	sumXiRi.Add(sumXiRi, new(big.Int).Mul(r.RandomSList.R4, r.RandomRList.R4))
	t := new(big.Int).Sub(r.R, sumXiRi)
	t.Mul(t, e)
	t.Add(t, r.RandomS)
	response := &RPResponse{
		Z1: z1,
		Z2: z2,
		Z3: z3,
		Z4: z4,
		T1: t1,
		T2: t2,
		T3: t3,
		T4: t4,
		T:  t,
	}
	return response, nil
}

// RPVerifier refers to the Verifier in zero-knowledge integer range proof
type RPVerifier struct {
	PP            *PublicParameters
	C             *big.Int
	SecurityParam *big.Int
	Commitment    *RPCommitment
}

func (r *RPVerifier) Challenge() (*big.Int, error) {
	eLmt := big.NewInt(2)
	eLmt.Exp(eLmt, r.SecurityParam, nil)
	e, err := PseudoFreshRandomCoin(eLmt)
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *RPVerifier) Verify(e *big.Int, cx *CommitX, response *RPResponse) bool {
	gPowZiHPowTiCiPowNegEModN1 := new(big.Int).Exp(r.PP.G, response.Z1, r.PP.N)
	gPowZiHPowTiCiPowNegEModN1.Mul(gPowZiHPowTiCiPowNegEModN1, new(big.Int).Exp(r.PP.H, response.T1, r.PP.N))
	c1PowEModInverse := new(big.Int).Exp(cx.C1, e, r.PP.N)
	c1PowEModInverse.ModInverse(c1PowEModInverse, r.PP.N)
	gPowZiHPowTiCiPowNegEModN1.Mul(gPowZiHPowTiCiPowNegEModN1, c1PowEModInverse)
	gPowZiHPowTiCiPowNegEModN1.Mod(gPowZiHPowTiCiPowNegEModN1, r.PP.N)

	gPowZiHPowTiCiPowNegEModN2 := new(big.Int).Exp(r.PP.G, response.Z2, r.PP.N)
	gPowZiHPowTiCiPowNegEModN2.Mul(gPowZiHPowTiCiPowNegEModN2, new(big.Int).Exp(r.PP.H, response.T2, r.PP.N))
	c2PowEModInverse := new(big.Int).Exp(cx.C2, e, r.PP.N)
	c2PowEModInverse.ModInverse(c2PowEModInverse, r.PP.N)
	gPowZiHPowTiCiPowNegEModN2.Mul(gPowZiHPowTiCiPowNegEModN2, c2PowEModInverse)
	gPowZiHPowTiCiPowNegEModN2.Mod(gPowZiHPowTiCiPowNegEModN2, r.PP.N)

	gPowZiHPowTiCiPowNegEModN3 := new(big.Int).Exp(r.PP.G, response.Z3, r.PP.N)
	gPowZiHPowTiCiPowNegEModN3.Mul(gPowZiHPowTiCiPowNegEModN3, new(big.Int).Exp(r.PP.H, response.T3, r.PP.N))
	c3PowEModInverse := new(big.Int).Exp(cx.C3, e, r.PP.N)
	c3PowEModInverse.ModInverse(c3PowEModInverse, r.PP.N)
	gPowZiHPowTiCiPowNegEModN3.Mul(gPowZiHPowTiCiPowNegEModN3, c3PowEModInverse)
	gPowZiHPowTiCiPowNegEModN3.Mod(gPowZiHPowTiCiPowNegEModN3, r.PP.N)

	gPowZiHPowTiCiPowNegEModN4 := new(big.Int).Exp(r.PP.G, response.Z4, r.PP.N)
	gPowZiHPowTiCiPowNegEModN4.Mul(gPowZiHPowTiCiPowNegEModN4, new(big.Int).Exp(r.PP.H, response.T4, r.PP.N))
	c4PowEModInverse := new(big.Int).Exp(cx.C4, e, r.PP.N)
	c4PowEModInverse.ModInverse(c4PowEModInverse, r.PP.N)
	gPowZiHPowTiCiPowNegEModN4.Mul(gPowZiHPowTiCiPowNegEModN4, c4PowEModInverse)
	gPowZiHPowTiCiPowNegEModN4.Mod(gPowZiHPowTiCiPowNegEModN4, r.PP.N)

	prodCiPowZiHPowTCPowNegE := new(big.Int).Exp(cx.C1, response.Z1, r.PP.N)
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(r.PP.H, response.T, r.PP.N))
	cPowEModInverse := new(big.Int).Exp(r.C, e, r.PP.N)
	cPowEModInverse.ModInverse(cPowEModInverse, r.PP.N)
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, cPowEModInverse)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.PP.N)

	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(cx.C2, response.Z2, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(r.PP.H, response.T, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, cPowEModInverse)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.PP.N)

	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(cx.C3, response.Z3, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(r.PP.H, response.T, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, cPowEModInverse)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.PP.N)

	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(cx.C4, response.Z4, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, new(big.Int).Exp(r.PP.H, response.T, r.PP.N))
	prodCiPowZiHPowTCPowNegE.Mul(prodCiPowZiHPowTCPowNegE, cPowEModInverse)
	prodCiPowZiHPowTCPowNegE.Mod(prodCiPowZiHPowTCPowNegE, r.PP.N)

	hashF := sha256.New()
	hashF.Write(gPowZiHPowTiCiPowNegEModN1.Bytes())
	hashF.Write(gPowZiHPowTiCiPowNegEModN2.Bytes())
	hashF.Write(gPowZiHPowTiCiPowNegEModN3.Bytes())
	hashF.Write(gPowZiHPowTiCiPowNegEModN4.Bytes())
	hashF.Write(prodCiPowZiHPowTCPowNegE.Bytes())
	h := hashF.Sum(nil)

	return bytes.Equal(h, r.Commitment.Content)
}

// PublicParameters holds public parameters initialized during the setup procedure
type PublicParameters struct {
	N *big.Int
	G *big.Int
	H *big.Int
}

// RPRandomCoins is the random coins used in range proof
type RPRandomCoins struct {
	R1 *big.Int
	R2 *big.Int
	R3 *big.Int
	R4 *big.Int
}

// NewRPRandomCoins creates a new random coins for range proof
func NewRPRandomCoins(n *big.Int) (*RPRandomCoins, error) {
	r1, err := PseudoFreshRandomCoin(n)
	if err != nil {
		return nil, err
	}
	r2, err := PseudoFreshRandomCoin(n)
	if err != nil {
		return nil, err
	}
	r3, err := PseudoFreshRandomCoin(n)
	if err != nil {
		return nil, err
	}
	r4, err := PseudoFreshRandomCoin(n)
	if err != nil {
		return nil, err
	}
	return &RPRandomCoins{r1, r2, r3, r4}, nil
}

// PseudoFreshRandomCoin creates a new fresh random coin in [0, n]
func PseudoFreshRandomCoin(n *big.Int) (*big.Int, error) {
	lmt := new(big.Int).Set(n)
	lmt.Add(lmt, big1)
	res, err := rand.Int(rand.Reader, lmt)
	if err != nil {
		return nil, err
	}
	return res, nil
}

// calBound calculates the bound B = log(b - a)
func calBound(r *RPRange) *big.Int {
	bMinusA := new(big.Int).Sub(r.B, r.A)
	// TODO: check log implementation
	bound := int64(bMinusA.BitLen() - 1)
	return new(big.Int).SetInt64(bound)
}

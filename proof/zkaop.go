// Package proof range proof via sum of three squares (3SPR)
// Paper: Removing the Strong RSA Assumption from Arguments over the Integers
// Link: https://eprint.iacr.org/2016/128
package proof

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"math/big"
)

const (
	zkAoPChallengeStatement = "c = (g^x)(h^r), x is non-negative"
	zkAoPCommitLen          = sha256Len * 4
)

var zkAoPB = big.NewInt(4096) // bound B

// ArgOfPositivity is the argument of positivity of an integer
type ArgOfPositivity struct {
	// commitment of x,
	// containing c1, c2, c3, ci = (g^xi)(h^ri),
	// which x = x1^2 + x2^2 + x3^2
	commit3 Int3
	// the commitment delta
	commitment zkAoPCommitment
	// the response to the challenge
	response *zkAoPResponse
}

// NewArgOfPositivity generates a new argument of positivity
func NewArgOfPositivity(commit3 Int3, commitment zkAoPCommitment, response *zkAoPResponse) *ArgOfPositivity {
	return &ArgOfPositivity{
		commit3:    commit3,
		commitment: commitment,
		response:   response,
	}
}

// zkAoPCommitment is the commitment of the argument of positivity generated by the prover
type zkAoPCommitment [zkAoPCommitLen]byte

// zkAoPChallenge is the challenge for the argument of positivity
type zkAoPChallenge struct {
	statement string   // the statement for the challenge
	g, h, n   *big.Int // public parameters: G, H, N
	c3        Int3     // commitment of x containing c1, c2, c3
}

// newZKAoPChallenge generates a new argument of positivity
func newZKAoPChallenge(pp *PublicParameters, c3 Int3) *zkAoPChallenge {
	return &zkAoPChallenge{
		statement: zkAoPChallengeStatement,
		g:         pp.G,
		h:         pp.H,
		n:         pp.N,
		c3:        c3,
	}
}

// Serialize generates the serialized data for the challenge of the argument of positivity in byte format
func (r *zkAoPChallenge) serialize() []byte {
	var buf bytes.Buffer
	buf.WriteString(r.statement)
	buf.WriteString(r.g.String())
	buf.WriteString(r.h.String())
	buf.WriteString(r.n.String())
	for _, c := range r.c3 {
		buf.WriteString(c.String())
	}
	return buf.Bytes()
}

// sha256 generates the SHA256 hash of the challenge of the argument of positivity
func (r *zkAoPChallenge) sha256() []byte {
	hashF := crypto.SHA256.New()
	_, err := hashF.Write(r.serialize())
	if err != nil {
		panic(err)
	}
	hashResult := hashF.Sum(nil)
	return hashResult
}

// bigInt serializes the argument-of-positivity challenge to bytes, generates the SHA256 hash of the byte data,
// and convert the hash to big integer
func (r *zkAoPChallenge) bigInt() *big.Int {
	hashVal := r.sha256()
	return new(big.Int).SetBytes(hashVal)
}

// zkAoPResponse is the response sent by the prover after receiving verifier's challenge
type zkAoPResponse struct {
	Z3 Int3
	T3 Int3
	T  *big.Int
}

// newZKAoPCommitment generates a new commitment for the argument of positivity
func newZKAoPCommitment(d3 Int3, d *big.Int) zkAoPCommitment {
	var dByteList [int3Len][]byte
	for i := 0; i < int3Len; i++ {
		dByteList[i] = d3[i].Bytes()
	}
	hashF := crypto.SHA256.New()
	var sha256List [int3Len][]byte
	for i, dByte := range dByteList {
		_, err := hashF.Write(dByte)
		if err != nil {
			panic(err)
		}
		sha256List[i] = hashF.Sum(nil)
		hashF.Reset()
	}
	var commitment zkAoPCommitment
	for idx, s := range sha256List {
		copy(commitment[idx*sha256Len:(idx+1)*sha256Len], s)
	}
	dBytes := d.Bytes()
	_, err := hashF.Write(dBytes)
	if err != nil {
		panic(err)
	}
	copy(commitment[zkAoPCommitLen-sha256Len:], hashF.Sum(nil))
	return commitment
}

// ZKAoPProver refers to the Prover in zero-knowledge integer argument of positivity
type ZKAoPProver struct {
	pp     *PublicParameters // public parameters
	r      *big.Int          // r
	sp     *big.Int          // security parameter, kappa
	C      *big.Int          // c = (g^x)(h^r)
	s      *big.Int          // random selected parameter s in [0, 2^(B/2 + 2kappa)*n]
	x3     Int3              // three square sum of 4x + 1 = x0^2 + x2^1 + x2^2
	c3     Int3              // commitment of three square sum of x: c0, c1, c2, ci = (g^xi)(h^ri)
	randM3 Int3              // random coins: m0, m1, m2, mi is in [0, 2^(B + 2kappa)]
	r3     Int3              // random coins: r0, r1, r2, ri is in [0, n]
	randS3 Int3              // random coins: s0, s1, s2, si is in [0, 2^(2kappa)*n]
}

// NewZKAoPProver generates a new argument-of-positivity prover
func NewZKAoPProver(pp *PublicParameters, r *big.Int) *ZKAoPProver {
	prover := &ZKAoPProver{
		pp: pp,
		r:  r,
		sp: big.NewInt(securityParam),
	}
	return prover
}

// Prove generates the proof for range proof
func (r *ZKAoPProver) Prove(x *big.Int) (*ArgOfPositivity, error) {
	r.C = calC(r.pp, r.r, x)
	cx, err := r.commitForX(x)
	if err != nil {
		return nil, err
	}
	commitment, err := r.commit()
	if err != nil {
		return nil, err
	}
	response, err := r.response()
	if err != nil {
		return nil, err
	}
	return NewArgOfPositivity(cx, commitment, response), nil
}

// commitForX generates the commitment for x
func (r *ZKAoPProver) commitForX(x *big.Int) (Int3, error) {
	// calculate three squares that 4x + 1 = x0^2 + x1^2 + x2^2
	target := iPool.Get().(*big.Int).Set(x)
	defer iPool.Put(target)
	target.Lsh(target, 2)
	target.Add(target, big1)
	ts, err := ThreeSquares(target)
	if err != nil {
		return Int3{}, err
	}
	r.x3 = ts
	// calculate commitment for x
	var rc Int3
	if rc, err = newThreeRandCoins(r.pp.N); err != nil {
		return Int3{}, err
	}
	for i := 0; i < int3Len; i++ {
		r.r3[i] = rc[i]
	}
	c3 := newZKAoPCommitFromTS(r.pp, rc, ts)
	r.c3 = c3
	return c3, nil
}

// newZKAoPCommitFromTS generates an argument-of-positivity commitment for a given integer
func newZKAoPCommitFromTS(pp *PublicParameters, coins Int3, ts Int3) (cList Int3) {
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	for i := 0; i < int3Len; i++ {
		cList[i] = new(big.Int).Exp(pp.G, ts[i], pp.N)
		cList[i].Mul(cList[i], opt.Exp(pp.H, coins[i], pp.N))
		cList[i].Mod(cList[i], pp.N)
	}
	return
}

// commit composes the commitment for range proof
func (r *ZKAoPProver) commit() (zkAoPCommitment, error) {
	// pick m0, m1, m2, mi is in [0, 2^(B + 2kappa)]
	powMLmt := iPool.Get().(*big.Int).Set(r.sp)
	defer iPool.Put(powMLmt)
	powMLmt.Lsh(powMLmt, 1)
	powMLmt.Add(powMLmt, zkAoPB)
	mLmt := iPool.Get().(*big.Int).Exp(big2, powMLmt, nil)
	defer iPool.Put(mLmt)
	m3, err := newThreeRandCoins(mLmt)
	if err != nil {
		return zkAoPCommitment{}, err
	}
	r.randM3 = m3
	// pick s0, s1, s2, si is in [0, 2^(2kappa)*n]
	sLmt := iPool.Get().(*big.Int).Exp(big4, r.sp, nil)
	defer iPool.Put(sLmt)
	sLmt.Mul(sLmt, r.pp.N)
	var s3 Int3
	if s3, err = newThreeRandCoins(sLmt); err != nil {
		return zkAoPCommitment{}, err
	}
	r.randS3 = s3
	// pick s in [0, 2^(B/2 + 2kappa)*n]
	sLmt.Lsh(sLmt, uint(zkAoPB.Int64())/2)
	var s *big.Int
	if s, err = freshRandCoin(sLmt); err != nil {
		return zkAoPCommitment{}, err
	}
	r.s = s
	// calculate commitment
	d3 := r.firstPartD(m3, s3)
	d := r.secondPartD(m3)
	c := newZKAoPCommitment(d3, d)
	return c, nil
}

// firstPartD calculates h0, h1, h2, hi = (g^mi)(h^si) mod n
func (r *ZKAoPProver) firstPartD(m, s Int3) Int3 {
	var h3 Int3
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	for i := 0; i < int3Len; i++ {
		h := new(big.Int).Exp(r.pp.G, m[i], r.pp.N)
		h.Mul(h, opt.Exp(r.pp.H, s[i], r.pp.N))
		h3[i] = h.Mod(h, r.pp.N)
	}
	return h3
}

// secondPartD calculates d = (product of (ci^mi)(h^s)) mod n
func (r *ZKAoPProver) secondPartD(m Int3) *big.Int {
	d := big.NewInt(1)
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	// product of (ci^mi)(h^s) mod n, for i = 0, 1, 2
	for i := 0; i < int3Len; i++ {
		d.Mul(
			d,
			opt.Exp(r.c3[i], m[i], r.pp.N),
		)
		d.Mod(d, r.pp.N)
	}
	hPowS := iPool.Get().(*big.Int).Exp(r.pp.H, r.s, r.pp.N)
	defer iPool.Put(hPowS)
	d.Mul(d, hPowS)
	d.Mod(d, r.pp.N)
	return d
}

// calChallengeBigInt calculates the challenge for range proof in big integer format
func (r *ZKAoPProver) calChallengeBigInt() *big.Int {
	challenge := newZKAoPChallenge(r.pp, r.c3)
	return challenge.bigInt()
}

// response generates the response for verifier's challenge
func (r *ZKAoPProver) response() (*zkAoPResponse, error) {
	e := r.calChallengeBigInt()
	// zi = e * xi + mi, for i = 0, 1, 2
	var z3 Int3
	for i := 0; i < int3Len; i++ {
		z3[i] = new(big.Int).Mul(e, r.x3[i])
		z3[i].Add(z3[i], r.randM3[i])
	}
	// ti = e * ri + si, for i = 0, 1, 2
	var t3 Int3
	for i := 0; i < int3Len; i++ {
		t3[i] = new(big.Int).Mul(e, r.r3[i])
		t3[i].Add(t3[i], r.randS3[i])
	}

	// t =e(4r - prod of xi*ri) + s
	t := new(big.Int).Lsh(r.r, 2)
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	for i := 0; i < int3Len; i++ {
		opt.Mul(r.x3[i], r.r3[i])
		t.Sub(t, opt)
	}
	t.Mul(t, e)
	t.Add(t, r.s)
	response := &zkAoPResponse{
		Z3: z3,
		T3: t3,
		T:  t,
	}
	return response, nil
}

// ZKAoPVerifier refers to the Verifier in zero-knowledge integer argument of positivity
type ZKAoPVerifier struct {
	pp         *PublicParameters // public parameters
	sp         *big.Int          // security parameters
	commitment zkAoPCommitment   // commitment, delta = H(d1, d2, d3, d4, d)
	c3         Int3              // c0, c1, c2 are the commitments of x
	c          *big.Int
}

// NewZKAoPVerifier generates a new integer argument of positivity verifier
func NewZKAoPVerifier(pp *PublicParameters, c *big.Int) *ZKAoPVerifier {
	verifier := &ZKAoPVerifier{
		pp: pp,
		sp: big.NewInt(securityParam),
		c:  c,
	}
	return verifier
}

// Verify verifies the argument of positivity
func (r *ZKAoPVerifier) Verify(proof *ArgOfPositivity) bool {
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	for i := 0; i < int3Len; i++ {
		r.c3[i] = proof.commit3[i]
	}
	r.commitment = proof.commitment
	return r.VerifyResponse(proof.response)
}

// challenge generates a challenge for prover's commitment
func (r *ZKAoPVerifier) challenge() *big.Int {
	var c3 Int3
	for i := 0; i < int3Len; i++ {
		c3[i] = r.c3[i]
	}
	challenge := newZKAoPChallenge(r.pp, c3)
	return challenge.bigInt()
}

// VerifyResponse verifies the response, if accepts, return true; otherwise, return false
func (r *ZKAoPVerifier) VerifyResponse(response *zkAoPResponse) bool {
	e := r.challenge()
	// the first 3 parameters: (g^zi)(h^ti)(ci^(-e)) mod n
	var firstThreeParams Int3
	negE := iPool.Get().(*big.Int).Neg(e)
	defer iPool.Put(negE)
	opt := iPool.Get().(*big.Int)
	defer iPool.Put(opt)
	for i := 0; i < int3Len; i++ {
		firstThreeParams[i] = new(big.Int).Exp(r.pp.G, response.Z3[i], r.pp.N)
		firstThreeParams[i].Mul(
			firstThreeParams[i],
			opt.Exp(r.pp.H, response.T3[i], r.pp.N),
		)
		firstThreeParams[i].Mul(
			firstThreeParams[i],
			opt.Exp(r.c3[i], negE, r.pp.N),
		)
		firstThreeParams[i].Mod(firstThreeParams[i], r.pp.N)
	}

	// prefix = h^tau * g^e * c_a^z_0 mod n
	lastH := new(big.Int).SetInt64(1)
	defer iPool.Put(lastH)
	//product of (ci^zi)(h^t)(c^(-e)) mod n
	for i := 0; i < int3Len; i++ {
		lastH.Mul(
			lastH,
			opt.Exp(r.c3[i], response.Z3[i], r.pp.N),
		)
		lastH.Mod(lastH, r.pp.N)
	}
	hPowTMulCPowNeg4E := iPool.Get().(*big.Int)
	defer iPool.Put(hPowTMulCPowNeg4E)
	neg4E := iPool.Get().(*big.Int).Lsh(negE, 2)
	defer iPool.Put(neg4E)
	hPowTMulCPowNeg4E.Exp(r.pp.H, response.T, r.pp.N)
	hPowTMulCPowNeg4E.Mul(hPowTMulCPowNeg4E, opt.Exp(r.c, neg4E, r.pp.N))
	hPowTMulCPowNeg4E.Mod(hPowTMulCPowNeg4E, r.pp.N)
	lastH.Mul(lastH, hPowTMulCPowNeg4E)
	lastH.Mod(lastH, r.pp.N)
	lastH.Mul(lastH, opt.Exp(r.pp.G, negE, r.pp.N))
	lastH.Mod(lastH, r.pp.N)

	hashF := sha256.New()
	var sha256List [int3Len][]byte
	for i := 0; i < int3Len; i++ {
		_, err := hashF.Write(firstThreeParams[i].Bytes())
		if err != nil {
			panic(err)
		}
		sha256List[i] = hashF.Sum(nil)
		hashF.Reset()
	}
	_, err := hashF.Write(lastH.Bytes())
	if err != nil {
		panic(err)
	}
	h := hashF.Sum(nil)
	var commitment zkAoPCommitment
	for i := 0; i < int3Len; i++ {
		copy(commitment[i*sha256Len:(i+1)*sha256Len], sha256List[i])
	}
	copy(commitment[zkAoPCommitLen-sha256Len:], h)
	return commitment == r.commitment
}
